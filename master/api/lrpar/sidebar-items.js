initSidebarItems({"enum":[["LexParseError","A lexing or parsing error. Although the two are quite distinct in terms of what can be reported to users, both can (at least conceptually) occur at any point of the intertwined lexing/parsing process."],["Node","A generic parse tree."],["ParseRepair","After a parse error is encountered, the parser attempts to find a way of recovering. Each entry in the sequence of repairs is represented by a `ParseRepair`."],["RecoveryKind","What recovery algorithm should be used when a syntax error is encountered?"]],"macro":[["lrpar_mod","A convenience macro for including statically compiled `.y` files. A file `src/a/b/c.y` which is statically compiled by lrpar can then be used in a crate with `lrpar_mod!(\"a/b/c.y\")`."]],"struct":[["CTParserBuilder","A `CTParserBuilder` allows one to specify the criteria for building a statically generated parser."],["LexError","A Lexing error."],["Lexeme","A `Lexeme` represents a segment of the user's input that conforms to a known type. Note that even if the type of a lexeme seemingly requires it to have `len() > 0` (e.g. integers might match the regular expressions `[0-9]+`), error recovery might cause a lexeme to have a length of 0. Users can detect the difference between a lexeme with an intentionally zero length from a lexeme with zero length due to error recovery through the `inserted` method."],["ParseError","Records a single parse error."],["RTParserBuilder","A run-time parser builder."],["Span","A `Span` records what portion of the user's input something (e.g. a lexeme or production) references (i.e. the `Span` doesn't hold a reference / copy of the actual input)."]],"trait":[["Lexer","The base trait which all lexers which want to interact with `lrpar` must implement."],["NonStreamingLexer","A `NonStreamingLexer` is one that takes input in one go, and is then able to hand out substrings to that input and calculate line and column numbers from a [Span]."]]});