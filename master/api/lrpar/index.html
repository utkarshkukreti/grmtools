<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `lrpar` crate."><meta name="keywords" content="rust, rustlang, rust-lang, lrpar"><title>lrpar - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../lrpar/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate lrpar</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all lrpar's items</p></a><div class="block items"><ul><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'lrpar', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/lrpar/mod.rs.html#1-248' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>lrpar</a></span></h1><div class='docblock'><p><code>lrpar</code> provides a Yacc-compatible parser (where grammars can be generated at
compile-time or run-time). It can take in traditional <code>.y</code> files and convert
them into an idiomatic Rust parser. More details can be found in the <a href="https://softdevteam.github.io/grmtools/master/book">grmtools
book</a>; the
<a href="https://softdevteam.github.io/grmtools/master/book/quickstart.html">quickstart guide</a>
is a good place to start.</p>
<h2 id="example" class="section-header"><a href="#example">Example</a></h2>
<p>Let's assume we want to statically generate a parser for a simple calculator
language (and let's also assume we are able to use
<a href="https://softdevteam.github.io/grmtools/master/book/lrlex.html"><code>lrlex</code></a> for the
lexer). We need to add a <code>build.rs</code> file to our project which tells <code>lrpar</code> to
statically compile the lexer and parser files:</p>
<pre><code class="language-text">use cfgrammar::yacc::YaccKind;
use lrlex::LexerBuilder;
use lrpar::CTParserBuilder;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let lex_rule_ids_map = CTParserBuilder::new()
        .yacckind(YaccKind::Grmtools)
        .process_file_in_src(&quot;calc.y&quot;)?;
    LexerBuilder::new()
        .rule_ids_map(lex_rule_ids_map)
        .process_file_in_src(&quot;calc.l&quot;)?;
    Ok(())
}
</code></pre>
<p>where <code>src/calc.l</code> is as follows:</p>
<pre><code class="language-text">%%
[0-9]+ &quot;INT&quot;
\+ &quot;+&quot;
\* &quot;*&quot;
\( &quot;(&quot;
\) &quot;)&quot;
[\t ]+ ;
</code></pre>
<p>and <code>src/calc.y</code> is as follows:</p>
<pre><code class="language-text">%start Expr
%avoid_insert &quot;INT&quot;
%%
Expr -&gt; Result&lt;u64, ()&gt;:
      Term '+' Expr { Ok($1? + $3?) }
    | Term { $1 }
    ;

Term -&gt; Result&lt;u64, ()&gt;:
      Factor '*' Term { Ok($1? * $3?) }
    | Factor { $1 }
    ;

Factor -&gt; Result&lt;u64, ()&gt;:
      '(' Expr ')' { $2 }
    | 'INT'
      {
          let v = $1.map_err(|_| ())?;
          parse_int($lexer.span_str(v.span()))
      }
    ;
%%
// Any functions here are in scope for all the grammar actions above.

fn parse_int(s: &amp;str) -&gt; Result&lt;u64, ()&gt; {
    match s.parse::&lt;u64&gt;() {
        Ok(val) =&gt; Ok(val),
        Err(_) =&gt; {
            eprintln!(&quot;{} cannot be represented as a u64&quot;, s);
            Err(())
        }
    }
}
</code></pre>
<p>Because we specified that our Yacc file is in <code>Grmtools</code> format, each rule has a
separate Rust type to which all its functions conform (in this case, all the
rules have the same type, but that's not a requirement).</p>
<p>A simple <code>src/main.rs</code> is as follows:</p>
<pre><code class="language-text">use std::io::{self, BufRead, Write};

use lrlex::lrlex_mod;
use lrpar::lrpar_mod;

// Using `lrlex_mod!` brings the lexer for `calc.l` into scope. By default the module name
// will be `calc_l` (i.e. the file name, minus any extensions, with a suffix of `_l`).
lrlex_mod!(&quot;calc.l&quot;);
// Using `lrpar_mod!` brings the parser for `calc.y` into scope. By default the module name
// will be `calc_y` (i.e. the file name, minus any extensions, with a suffix of `_y`).
lrpar_mod!(&quot;calc.y&quot;);

fn main() {
    // Get the `LexerDef` for the `calc` language.
    let lexerdef = calc_l::lexerdef();
    let stdin = io::stdin();
    loop {
        print!(&quot;&gt;&gt;&gt; &quot;);
        io::stdout().flush().ok();
        match stdin.lock().lines().next() {
            Some(Ok(ref l)) =&gt; {
                if l.trim().is_empty() {
                    continue;
                }
                // Now we create a lexer with the `lexer` method with which we can lex an input.
                let lexer = lexerdef.lexer(l);
                // Pass the lexer to the parser and lex and parse the input.
                let (res, errs) = calc_y::parse(&amp;lexer);
                for e in errs {
                    println!(&quot;{}&quot;, e.pp(&amp;lexer, &amp;calc_y::token_epp));
                }
                match res {
                    Some(Ok(r)) =&gt; println!(&quot;Result: {}&quot;, r),
                    _ =&gt; eprintln!(&quot;Unable to evaluate expression.&quot;)
                }
            }
            _ =&gt; break
        }
    }
}
</code></pre>
<p>We can now <code>cargo run</code> our project and evaluate simple expressions:</p>
<pre><code class="language-text">&gt;&gt;&gt; 2 + 3
Result: 5
&gt;&gt;&gt; 2 + 3 * 4
Result: 14
&gt;&gt;&gt; (2 + 3) * 4
Result: 20
</code></pre>
<p><code>lrpar</code> also comes with advanced <a href="https://softdevteam.github.io/grmtools/master/book/errorrecovery.html">error
recovery</a> built-in:</p>
<pre><code class="language-text">&gt;&gt;&gt; 2 + + 3
Parsing error at line 1 column 5. Repair sequences found:
   1: Delete +
   2: Insert INT
Result: 5
&gt;&gt;&gt; 2 + 3 3
Parsing error at line 1 column 7. Repair sequences found:
   1: Insert *
   2: Insert +
   3: Delete 3
Result: 11
&gt;&gt;&gt; 2 + 3 4 5
Parsing error at line 1 column 7. Repair sequences found:
   1: Insert *, Delete 4
   2: Insert +, Delete 4
   3: Delete 4, Delete 5
   4: Insert +, Shift 4, Delete 5
   5: Insert +, Shift 4, Insert +
   6: Insert *, Shift 4, Delete 5
   7: Insert *, Shift 4, Insert *
   8: Insert *, Shift 4, Insert +
   9: Insert +, Shift 4, Insert *
Result: 17
</code></pre>
</div><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table><tr class='module-item'><td><a class="macro" href="macro.lrpar_mod.html" title='lrpar::lrpar_mod macro'>lrpar_mod</a></td><td class='docblock-short'><p>A convenience macro for including statically compiled <code>.y</code> files. A file <code>src/a/b/c.y</code> which is
statically compiled by lrpar can then be used in a crate with <code>lrpar_mod!(&quot;a/b/c.y&quot;)</code>.</p>
</td></tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.CTParserBuilder.html" title='lrpar::CTParserBuilder struct'>CTParserBuilder</a></td><td class='docblock-short'><p>A <code>CTParserBuilder</code> allows one to specify the criteria for building a statically generated
parser.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.LexError.html" title='lrpar::LexError struct'>LexError</a></td><td class='docblock-short'><p>A Lexing error.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Lexeme.html" title='lrpar::Lexeme struct'>Lexeme</a></td><td class='docblock-short'><p>A <code>Lexeme</code> represents a segment of the user's input that conforms to a known type. Note that
even if the type of a lexeme seemingly requires it to have <code>len() &gt; 0</code> (e.g. integers might
match the regular expressions <code>[0-9]+</code>), error recovery might cause a lexeme to have a length
of 0. Users can detect the difference between a lexeme with an intentionally zero length from a
lexeme with zero length due to error recovery through the
<a href="../lrpar/struct.Lexeme.html#method.inserted"><code>inserted</code></a> method.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.ParseError.html" title='lrpar::ParseError struct'>ParseError</a></td><td class='docblock-short'><p>Records a single parse error.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.RTParserBuilder.html" title='lrpar::RTParserBuilder struct'>RTParserBuilder</a></td><td class='docblock-short'><p>A run-time parser builder.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Span.html" title='lrpar::Span struct'>Span</a></td><td class='docblock-short'><p>A <code>Span</code> records what portion of the user's input something (e.g. a lexeme or production)
references (i.e. the <code>Span</code> doesn't hold a reference / copy of the actual input).</p>
</td></tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table><tr class='module-item'><td><a class="enum" href="enum.LexParseError.html" title='lrpar::LexParseError enum'>LexParseError</a></td><td class='docblock-short'><p>A lexing or parsing error. Although the two are quite distinct in terms of what can be reported
to users, both can (at least conceptually) occur at any point of the intertwined lexing/parsing
process.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.Node.html" title='lrpar::Node enum'>Node</a></td><td class='docblock-short'><p>A generic parse tree.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.ParseRepair.html" title='lrpar::ParseRepair enum'>ParseRepair</a></td><td class='docblock-short'><p>After a parse error is encountered, the parser attempts to find a way of recovering. Each entry
in the sequence of repairs is represented by a <code>ParseRepair</code>.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.RecoveryKind.html" title='lrpar::RecoveryKind enum'>RecoveryKind</a></td><td class='docblock-short'><p>What recovery algorithm should be used when a syntax error is encountered?</p>
</td></tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table><tr class='module-item'><td><a class="trait" href="trait.Lexer.html" title='lrpar::Lexer trait'>Lexer</a></td><td class='docblock-short'><p>The base trait which all lexers which want to interact with <code>lrpar</code> must implement.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.NonStreamingLexer.html" title='lrpar::NonStreamingLexer trait'>NonStreamingLexer</a></td><td class='docblock-short'><p>A <code>NonStreamingLexer</code> is one that takes input in one go, and is then able to hand out
substrings to that input and calculate line and column numbers from a <a href="../lrpar/struct.Span.html" title="Span">Span</a>.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "lrpar";</script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>